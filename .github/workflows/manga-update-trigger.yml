name: Manga Update Trigger (Smart Batch + Deploy)

on:
  repository_dispatch:
    types: 
      - manga-updated
  
  schedule:
    - cron: '0 2 * * *'  # Daily at 02:00 UTC (09:00 WIB) - backup only
  
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: manga-updates
  cancel-in-progress: false

jobs:
  batch-updates:
    runs-on: ubuntu-latest
    outputs:
      should_rebuild: ${{ steps.check_rebuild.outputs.should_rebuild }}
      manga_list: ${{ steps.check_rebuild.outputs.manga_list }}
      version: ${{ steps.version.outputs.version }}
      needs_cover_update: ${{ steps.cover_check.outputs.needs_cover_update }}
    
    steps:
      - name: ğŸ”§ Checkout Website Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: ğŸ“Š Initialize Pending Tracker
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          if [ ! -f pending-manga-updates.json ]; then
            echo '{"pending":[],"lastRebuild":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > pending-manga-updates.json
          fi
      
      - name: ğŸ“ Add Update to Pending
        if: github.event_name == 'repository_dispatch'
        run: |
          MANGA_REPO="${{ github.event.client_payload.manga }}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          echo "ğŸ“š New update from: $MANGA_REPO"
          
          jq --arg repo "$MANGA_REPO" --arg ts "$TIMESTAMP" \
            '.pending |= (. + [{"repo": $repo, "timestamp": $ts}] | unique_by(.repo))' \
            pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          git add pending-manga-updates.json
          git commit -m "ğŸ“ Track update from $MANGA_REPO [skip ci]" || echo "No changes"
          git push || echo "Push failed"
          
          PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
          echo "âœ… Queued. Total pending: $PENDING_COUNT"
      
      - name: ğŸ” Check if Should Rebuild
        id: check_rebuild
        run: |
          PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
          LAST_REBUILD=$(jq -r '.lastRebuild' pending-manga-updates.json)
          CURRENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          LAST_EPOCH=$(date -d "$LAST_REBUILD" +%s 2>/dev/null || echo "0")
          CURRENT_EPOCH=$(date -d "$CURRENT_TIME" +%s)
          MINUTES_SINCE=$((($CURRENT_EPOCH - $LAST_EPOCH) / 60))
          
          echo "ğŸ“Š Pending: $PENDING_COUNT manga"
          echo "â° Minutes since rebuild: $MINUTES_SINCE"
          
          if [ "$PENDING_COUNT" -gt 0 ]; then
            if [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "should_rebuild=true" >> $GITHUB_OUTPUT
              MANGA_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd "," -)
              echo "manga_list=$MANGA_LIST" >> $GITHUB_OUTPUT
              echo "âœ… Scheduled/manual run - will rebuild: $MANGA_LIST"
            elif [ "$PENDING_COUNT" -eq 1 ] && [ "$MINUTES_SINCE" -lt 5 ]; then
              echo "should_rebuild=false" >> $GITHUB_OUTPUT
              echo "â³ First update, waiting for batching... ($MINUTES_SINCE/5 min)"
            else
              echo "should_rebuild=true" >> $GITHUB_OUTPUT
              MANGA_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd "," -)
              echo "manga_list=$MANGA_LIST" >> $GITHUB_OUTPUT
              echo "âœ… Will rebuild for: $MANGA_LIST"
            fi
          else
            echo "should_rebuild=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No pending updates"
          fi
      
      - name: ğŸ–¼ï¸ Quick Cover Check
        id: cover_check
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          echo "ğŸ–¼ï¸ Checking if any manga needs cover update..."
          
          npm install --no-save node-fetch@2
          
          cat > check-covers.js << 'COVER_CHECK_EOF'
          const fs = require('fs');
          const fetch = require('node-fetch');
          
          const MANGA_LIST = JSON.parse(fs.readFileSync('pending-manga-updates.json', 'utf8')).pending;
          
          async function checkCover(repoName) {
            try {
              const url = `https://raw.githubusercontent.com/nurananto/${repoName}/main/manga.json`;
              const res = await fetch(url);
              if (!res.ok) return null;
              
              const data = await res.json();
              const mdUrl = data.manga?.links?.mangadex;
              if (!mdUrl) return null;
              
              const mdId = mdUrl.match(/\/title\/([a-f0-9-]+)/)?.[1];
              if (!mdId) return null;
              
              const apiUrl = `https://api.mangadex.org/cover?manga[]=${mdId}&limit=1&order[createdAt]=desc`;
              const coverRes = await fetch(apiUrl);
              if (!coverRes.ok) return null;
              
              const coverData = await coverRes.json();
              if (!coverData.data?.[0]) return null;
              
              const latestHash = coverData.data[0].attributes.fileName.split('.')[0];
              const currentCover = data.manga.cover || '';
              const hasLatest = currentCover.includes(latestHash);
              
              return { repo: repoName, needsUpdate: !hasLatest, hash: latestHash };
            } catch (err) {
              console.warn(`âš ï¸ ${repoName}: ${err.message}`);
              return null;
            }
          }
          
          (async () => {
            const results = [];
            for (const item of MANGA_LIST) {
              const result = await checkCover(item.repo);
              if (result) results.push(result);
              await new Promise(r => setTimeout(r, 1000));
            }
            
            const needsUpdate = results.filter(r => r.needsUpdate);
            console.log(`\nğŸ“Š Cover check results:`);
            console.log(`   Total checked: ${results.length}`);
            console.log(`   Needs update: ${needsUpdate.length}`);
            
            if (needsUpdate.length > 0) {
              console.log(`\nğŸ–¼ï¸ Manga with new covers:`);
              needsUpdate.forEach(r => console.log(`   - ${r.repo}`));
            }
            
            fs.writeFileSync('cover-check-result.json', JSON.stringify({ needsUpdate: needsUpdate.length > 0 }));
          })();
          COVER_CHECK_EOF
          
          node check-covers.js || echo "Cover check failed, continuing..."
          
          if [ -f cover-check-result.json ]; then
            NEEDS_UPDATE=$(cat cover-check-result.json | jq -r '.needsUpdate')
            echo "needs_cover_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          else
            echo "needs_cover_update=false" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ”„ Update Covers (If Needed)
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_ACCESS_KEY_ID: ${{ secrets.CF_ACCESS_KEY_ID }}
          CF_SECRET_ACCESS_KEY: ${{ secrets.CF_SECRET_ACCESS_KEY }}
          R2_PUBLIC_DOMAIN: ${{ secrets.R2_PUBLIC_DOMAIN }}
        run: |
          echo "ğŸ–¼ï¸ Updating covers..."
          npm install sharp @aws-sdk/client-s3
          node download-covers-r2.js || echo "Cover update failed, continuing..."
          
          if [[ -n $(git status -s manga-config.js) ]]; then
            git add manga-config.js repo-list.txt
            git commit -m "ğŸ–¼ï¸ Auto-update covers [skip ci]" || true
            git push || true
            echo "âœ… Covers updated"
          fi
      
      - name: ğŸ“¤ Trigger Cover Sync to Manga Repos
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        run: |
          echo "ğŸ“¤ Triggering cover sync to all manga repos..."
          
          if [ ! -f "repo-list.txt" ]; then
            echo "âŒ repo-list.txt not found!"
            exit 0
          fi
          
          repo_count=$(wc -l < repo-list.txt)
          echo "ğŸ“Š Found $repo_count repos to trigger"
          
          success=0
          failed=0
          
          while IFS= read -r repo; do
            if [ -z "$repo" ]; then
              continue
            fi
            
            echo "  [TRIGGER] $repo..."
            
            http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
              https://api.github.com/repos/nurananto/$repo/dispatches \
              -d '{"event_type":"sync-covers"}')
            
            if [ "$http_code" = "204" ]; then
              echo "    âœ… Success"
              ((success++))
            else
              echo "    âŒ Failed (HTTP $http_code)"
              ((failed++))
            fi
            
            sleep 1
          done < repo-list.txt
          
          echo ""
          echo "=========================================="
          echo "ğŸ“¤ Cover Sync Trigger Summary:"
          echo "   âœ… Success: $success repos"
          echo "   âŒ Failed: $failed repos"
          echo "   ğŸ“Š Total: $repo_count repos"
          echo "   â„¹ï¸  Repos will update with [skip ci]"
          echo "=========================================="
      
      - name: ğŸ“„ Generate Version Bump
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        id: version
        run: |
          VERSION=$(git rev-parse --short HEAD)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ New version: $VERSION"
          
          echo "$VERSION" > version.txt
          
          sed -i "s/const CACHE_NAME = 'nurananto-v[0-9a-f]*'/const CACHE_NAME = 'nurananto-v$VERSION'/g" sw.js
          sed -i "s/const STATIC_CACHE = 'static-v[0-9a-f]*'/const STATIC_CACHE = 'static-v$VERSION'/g" sw.js
          sed -i "s/const IMAGE_CACHE = 'images-v[0-9a-f]*'/const IMAGE_CACHE = 'images-v$VERSION'/g" sw.js
          sed -i "s/const DYNAMIC_CACHE = 'dynamic-v[0-9a-f]*'/const DYNAMIC_CACHE = 'dynamic-v$VERSION'/g" sw.js
          
          echo "âœ… Cache version updated"
      
      - name: ğŸ’¾ Commit Changes
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          MANGA_LIST="${{ steps.check_rebuild.outputs.manga_list }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          git add version.txt sw.js
          git commit -m "ğŸ“„ Batch rebuild: $MANGA_LIST (v$VERSION)" || echo "No changes"
          git push
          
          echo "âœ… Version committed"
      
      - name: ğŸ§¹ Clear Pending
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          jq --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '.pending = [] | .lastRebuild = $ts' \
            pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
          
          git add pending-manga-updates.json
          git commit -m "ğŸ§¹ Clear pending [skip ci]"
          git push

  # âœ… Separate job to deploy pages
  deploy-pages:
    needs: batch-updates
    if: needs.batch-updates.outputs.should_rebuild == 'true'
    uses: ./.github/workflows/deploy-pages.yml
  
  # Purge cache after deploy
  purge-cache:
    needs: [batch-updates, deploy-pages]
    if: needs.batch-updates.outputs.should_rebuild == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ—‘ï¸ Purge Cloudflare Cache
        run: |
          if [ -n "${{ secrets.CF_ZONE_ID }}" ] && [ -n "${{ secrets.CF_API_TOKEN }}" ]; then
            echo "ğŸŒ Purging Cloudflare cache..."
            
            response=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
              -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data '{"purge_everything":true}')
            
            echo "Response: $response"
            echo "âœ… Cache purged!"
          else
            echo "âš ï¸ Cloudflare credentials not found, skipping purge"
          fi
      
      - name: âœ… Complete
        run: |
          echo "ğŸ‰ Batch rebuild complete!"
          echo "ğŸ“± Updates:"
          echo "   - Manga: ${{ needs.batch-updates.outputs.manga_list }}"
          echo "   - Version: ${{ needs.batch-updates.outputs.version }}"
          if [ "${{ needs.batch-updates.outputs.needs_cover_update }}" = "true" ]; then
            echo "   - Covers: Updated & synced to repos with [skip ci]"
          fi
          echo "ğŸ”— Website: https://nuranantoscans.my.id"