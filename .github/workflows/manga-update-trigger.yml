name: Manga Update Trigger (Smart Batch + Deploy)

on:
  repository_dispatch:
    types: 
      - manga-updated
  
  schedule:
    - cron: '0 2 * * *'  # Daily at 02:00 UTC (09:00 WIB) - backup only
  
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: manga-updates
  cancel-in-progress: false

jobs:
  batch-updates:
    runs-on: ubuntu-latest
    outputs:
      should_rebuild: ${{ steps.check_rebuild.outputs.should_rebuild }}
      manga_list: ${{ steps.check_rebuild.outputs.manga_list }}
      version: ${{ steps.version.outputs.version }}
      needs_cover_update: ${{ steps.cover_check.outputs.needs_cover_update }}
    
    steps:
      - name: üîß Checkout Website Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: üìä Initialize Pending Tracker
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          if [ ! -f pending-manga-updates.json ]; then
            echo '{"pending":[],"lastRebuild":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > pending-manga-updates.json
          fi
      
      - name: üìù Add Update to Pending
        if: github.event_name == 'repository_dispatch'
        run: |
          MANGA_REPO="${{ github.event.client_payload.manga }}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          echo "üìö New update from: $MANGA_REPO"
          
          jq --arg repo "$MANGA_REPO" --arg ts "$TIMESTAMP" \
            '.pending |= (. + [{"repo": $repo, "timestamp": $ts}] | unique_by(.repo))' \
            pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          git add pending-manga-updates.json
          git commit -m "üìù Track update from $MANGA_REPO [skip ci]" || echo "No changes"
          git push || echo "Push failed"
          
          PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
          echo "‚úÖ Queued. Total pending: $PENDING_COUNT"
      
      - name: üîç Check if Should Rebuild
        id: check_rebuild
        run: |
          PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
    
          echo "üìä Pending: $PENDING_COUNT manga"
    
          if [ "$PENDING_COUNT" -gt 0 ]; then
          echo "should_rebuild=true" >> $GITHUB_OUTPUT
          MANGA_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd "," -)
          echo "manga_list=$MANGA_LIST" >> $GITHUB_OUTPUT
          echo "‚úÖ Instant rebuild for: $MANGA_LIST"
          else
          echo "should_rebuild=false" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è No pending updates"
          fi
      
      - name: üñºÔ∏è Quick Cover Check
        id: cover_check
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          echo "üñºÔ∏è Checking if any manga needs cover update..."
          
          npm install --no-save node-fetch@2
          
          cat > check-covers.js << 'COVER_CHECK_EOF'
          const fs = require('fs');
          const fetch = require('node-fetch');
          
          const MANGA_LIST = JSON.parse(fs.readFileSync('pending-manga-updates.json', 'utf8')).pending;
          
          async function checkCover(repoName) {
            try {
              const url = `https://raw.githubusercontent.com/nurananto/${repoName}/main/manga.json`;
              const res = await fetch(url);
              if (!res.ok) return null;
              
              const data = await res.json();
              const mdUrl = data.manga?.links?.mangadex;
              if (!mdUrl) return null;
              
              const mdId = mdUrl.match(/\/title\/([a-f0-9-]+)/)?.[1];
              if (!mdId) return null;
              
              const apiUrl = `https://api.mangadex.org/cover?manga[]=${mdId}&limit=1&order[createdAt]=desc`;
              const coverRes = await fetch(apiUrl);
              if (!coverRes.ok) return null;
              
              const coverData = await coverRes.json();
              if (!coverData.data?.[0]) return null;
              
              const latestHash = coverData.data[0].attributes.fileName.split('.')[0];
              const currentCover = data.manga.cover || '';
              const hasLatest = currentCover.includes(latestHash);
              
              return { repo: repoName, needsUpdate: !hasLatest, hash: latestHash };
            } catch (err) {
              console.warn(`‚ö†Ô∏è ${repoName}: ${err.message}`);
              return null;
            }
          }
          
          (async () => {
            const results = [];
            for (const item of MANGA_LIST) {
              const result = await checkCover(item.repo);
              if (result) results.push(result);
              await new Promise(r => setTimeout(r, 1000));
            }
            
            const needsUpdate = results.filter(r => r.needsUpdate);
            console.log(`\nüìä Cover check results:`);
            console.log(`   Total checked: ${results.length}`);
            console.log(`   Needs update: ${needsUpdate.length}`);
            
            if (needsUpdate.length > 0) {
              console.log(`\nüñºÔ∏è Manga with new covers:`);
              needsUpdate.forEach(r => console.log(`   - ${r.repo}`));
            }
            
            fs.writeFileSync('cover-check-result.json', JSON.stringify({ needsUpdate: needsUpdate.length > 0 }));
          })();
          COVER_CHECK_EOF
          
          node check-covers.js || echo "Cover check failed, continuing..."
          
          if [ -f cover-check-result.json ]; then
            NEEDS_UPDATE=$(cat cover-check-result.json | jq -r '.needsUpdate')
            echo "needs_cover_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          else
            echo "needs_cover_update=false" >> $GITHUB_OUTPUT
          fi
      
      - name: üîÑ Update Covers (If Needed)
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_ACCESS_KEY_ID: ${{ secrets.CF_ACCESS_KEY_ID }}
          CF_SECRET_ACCESS_KEY: ${{ secrets.CF_SECRET_ACCESS_KEY }}
          R2_PUBLIC_DOMAIN: ${{ secrets.R2_PUBLIC_DOMAIN }}
        run: |
          echo "üñºÔ∏è Updating covers..."
          npm install sharp @aws-sdk/client-s3
          node download-covers-r2.js || echo "Cover update failed, continuing..."
          
          if [[ -n $(git status -s manga-config.js) ]]; then
            git add manga-config.js updated-repo-list.txt
            git commit -m "üñºÔ∏è Auto-update covers [skip ci]" || true
            git push || true
            echo "‚úÖ Covers updated"
          fi
      
      - name: üì§ Trigger Cover Sync to Updated Manga Repos ONLY
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        run: |
          set +e  # Don't exit on error
          
          echo "üì§ Triggering cover sync to repos with updated covers ONLY..."
          
          # Use updated-repo-list.txt instead of repo-list.txt
          REPO_FILE="updated-repo-list.txt"
          
          if [ ! -f "$REPO_FILE" ]; then
            echo "‚ÑπÔ∏è No updated-repo-list.txt found - no repos to trigger"
            exit 0
          fi
          
          repo_count=$(wc -l < "$REPO_FILE")
          
          if [ "$repo_count" -eq 0 ]; then
            echo "‚ÑπÔ∏è No repos in updated list - skipping triggers"
            exit 0
          fi
          
          echo "üìä Found $repo_count repos with cover updates"
          
          success=0
          failed=0
          skipped=0
          
          while IFS= read -r repo; do
            if [ -z "$repo" ]; then
              continue
            fi
            
            echo "  [TRIGGER] $repo..."
            
            http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.PAT_TOKEN }}" \
              https://api.github.com/repos/nurananto/$repo/dispatches \
              -d '{"event_type":"sync-covers"}' 2>&1 || echo "000")
            
            if [ "$http_code" = "204" ]; then
              echo "    ‚úÖ Success"
              success=$((success + 1))
            elif [ "$http_code" = "404" ]; then
              echo "    ‚ö†Ô∏è Workflow not found (HTTP 404)"
              skipped=$((skipped + 1))
            else
              echo "    ‚ùå Failed (HTTP $http_code)"
              failed=$((failed + 1))
            fi
            
            sleep 1
          done < "$REPO_FILE"
          
          echo ""
          echo "=========================================="
          echo "üì§ Cover Sync Trigger Summary:"
          echo "   ‚úÖ Success: $success repos"
          echo "   ‚ö†Ô∏è Skipped: $skipped repos (workflow missing)"
          echo "   ‚ùå Failed: $failed repos"
          echo "   üìä Total Updated: $repo_count repos"
          echo "   ‚ÑπÔ∏è  Repos will update with [skip ci]"
          echo "=========================================="
          
          # Exit with success if at least one trigger succeeded
          if [ $success -gt 0 ]; then
            echo ""
            echo "‚úÖ At least $success repos triggered successfully"
            exit 0
          elif [ $skipped -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è No triggers succeeded, but $skipped repos need sync-cover.yml"
            exit 0
          else
            echo ""
            echo "‚ùå All trigger attempts failed"
            exit 1
          fi
      
      - name: üßπ Cleanup Updated Repo List
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        run: |
          echo "üßπ Cleaning up updated-repo-list.txt..."
          
          if [ -f "updated-repo-list.txt" ]; then
            git config --local user.name "github-actions[bot]"
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            
            rm updated-repo-list.txt
            git add updated-repo-list.txt
            git commit -m "üßπ Cleanup updated repo list [skip ci]" || echo "No changes to commit"
            git push || echo "Push failed"
            
            echo "‚úÖ updated-repo-list.txt removed"
          else
            echo "‚ÑπÔ∏è File not found, nothing to clean"
          fi
      
      - name: üîÑ Generate Version Bump
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        id: version
        run: |
          VERSION=$(git rev-parse --short HEAD)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ New version: $VERSION"
          
          echo "$VERSION" > version.txt
          
          sed -i "s/const CACHE_NAME = 'nurananto-v[0-9a-f]*'/const CACHE_NAME = 'nurananto-v$VERSION'/g" sw.js
          sed -i "s/const STATIC_CACHE = 'static-v[0-9a-f]*'/const STATIC_CACHE = 'static-v$VERSION'/g" sw.js
          sed -i "s/const IMAGE_CACHE = 'images-v[0-9a-f]*'/const IMAGE_CACHE = 'images-v$VERSION'/g" sw.js
          sed -i "s/const DYNAMIC_CACHE = 'dynamic-v[0-9a-f]*'/const DYNAMIC_CACHE = 'dynamic-v$VERSION'/g" sw.js
          
          echo "‚úÖ Cache version updated"
      
      - name: üíæ Commit Changes
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          MANGA_LIST="${{ steps.check_rebuild.outputs.manga_list }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          git add version.txt sw.js
          git commit -m "üîÑ Batch rebuild: $MANGA_LIST (v$VERSION)" || echo "No changes"
          git push
          
          echo "‚úÖ Version committed"
      
      - name: üßπ Clear Pending
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          jq --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '.pending = [] | .lastRebuild = $ts' \
            pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
          
          git add pending-manga-updates.json
          git commit -m "üßπ Clear pending [skip ci]"
          git push

  # ‚úÖ Separate job to deploy pages
  deploy-pages:
    needs: batch-updates
    if: needs.batch-updates.outputs.should_rebuild == 'true'
    uses: ./.github/workflows/deploy-pages.yml
  
  # Purge cache after deploy
  purge-cache:
    needs: [batch-updates, deploy-pages]
    if: needs.batch-updates.outputs.should_rebuild == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: üóëÔ∏è Purge Cloudflare Cache
        run: |
          if [ -n "${{ secrets.CF_ZONE_ID }}" ] && [ -n "${{ secrets.CF_API_TOKEN }}" ]; then
          echo "üåê Purging Cloudflare cache..."
      
          # Purge specific files first
          echo "üóëÔ∏è Purging critical files..."
          curl -s -X POST \
          "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
          -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          --data '{
          "files": [
            "https://nuranantoscans.my.id/version.txt",
            "https://nuranantoscans.my.id/sw.js",
            "https://nuranantoscans.my.id/manga-config.js"
            ]
          }'
     
          sleep 2
      
          # Purge everything
          echo "üóëÔ∏è Purging all cache..."
          curl -s -X POST \
          "https://api.cloudflare.com/client/v4/zones/${{ secrets.CF_ZONE_ID }}/purge_cache" \
          -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          --data '{"purge_everything":true}'
      
          echo "‚úÖ Cache purged!"
          else
             echo "‚ö†Ô∏è Cloudflare credentials not found, skipping purge"
           fi