name: Manga Update Trigger (Smart Batch + Deploy)

on:
  repository_dispatch:
    types: 
      - manga-updated
  
  schedule:
    - cron: '0 2 * * *'  # Daily at 02:00 UTC (09:00 WIB) - backup only
  
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write
  actions: write  # ‚úÖ Required for deploy-pages.yml to trigger auto-version

concurrency:
  group: manga-updates
  cancel-in-progress: false

env:
  DEBOUNCE_SECONDS: 15

jobs:
  batch-updates:
    runs-on: ubuntu-latest
    outputs:
      should_rebuild: ${{ steps.check_rebuild.outputs.should_rebuild }}
      manga_list: ${{ steps.check_rebuild.outputs.manga_list }}
      needs_cover_update: ${{ steps.cover_check.outputs.needs_cover_update }}
    
    steps:
      - name: üîß Checkout Website Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: üìä Initialize Pending Tracker
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          
          if [ ! -f pending-manga-updates.json ]; then
            echo '{"pending":[],"lastRebuild":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > pending-manga-updates.json
          fi
      
      - name: üîç Add Update to Pending (with retry)
        if: github.event_name == 'repository_dispatch'
        run: |
          MANGA_REPO="${{ github.event.client_payload.manga }}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          echo "üìö New update from: $MANGA_REPO"
          
          MAX_RETRIES=5
          RETRY_DELAY=3
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Attempt $i/$MAX_RETRIES to add update..."
            
            git pull --rebase || git pull || true
            
            jq --arg repo "$MANGA_REPO" --arg ts "$TIMESTAMP" \
              '.pending |= (. + [{"repo": $repo, "timestamp": $ts}] | unique_by(.repo))' \
              pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
            
            git config --local user.name "github-actions[bot]"
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            
            git add pending-manga-updates.json
            git commit -m "üîç Track update from $MANGA_REPO [skip ci]" || echo "No changes"
            
            if git push; then
              PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
              PENDING_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd ", " -)
              echo "‚úÖ Queued. Total pending: $PENDING_COUNT"
              echo "üìã Pending repos: $PENDING_LIST"
              echo "::notice title=Update Queued::Added $MANGA_REPO to pending queue (Total: $PENDING_COUNT)"
              break
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Push failed, retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
              else
                echo "‚ùå Failed after $MAX_RETRIES attempts, but continuing..."
              fi
            fi
          done
      
      - name: ‚è≥ Debounce - Wait for Batch Collection
        if: github.event_name == 'repository_dispatch'
        run: |
          echo "‚è≥ Waiting ${{ env.DEBOUNCE_SECONDS }} seconds to collect batch updates..."
          echo "   (This allows multiple repos to queue their updates before processing)"
          
          sleep ${{ env.DEBOUNCE_SECONDS }}
          
          echo "‚úÖ Debounce complete, proceeding with batch processing"
      
      - name: üîÑ Sync Latest Pending Updates
        run: |
          echo "üîÑ Pulling latest pending-manga-updates.json to get all queued updates..."
          
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            if git pull --rebase || git pull; then
              echo "‚úÖ Successfully synced"
              break
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Sync failed, retrying in 2 seconds..."
                sleep 2
              else
                echo "‚ö†Ô∏è Sync failed after $MAX_RETRIES attempts, continuing with local version..."
              fi
            fi
          done
          
          if [ ! -f pending-manga-updates.json ]; then
            echo '{"pending":[],"lastRebuild":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > pending-manga-updates.json
          fi
      
      - name: üîç Check if Should Rebuild
        id: check_rebuild
        run: |
          echo "üìã Current pending-manga-updates.json content:"
          cat pending-manga-updates.json | jq '.'
          echo ""
          
          PENDING_COUNT=$(jq '.pending | length' pending-manga-updates.json)
          LAST_REBUILD=$(jq -r '.lastRebuild // "never"' pending-manga-updates.json)
    
          echo "üìä Pending: $PENDING_COUNT manga"
          echo "üïê Last rebuild: $LAST_REBUILD"
          echo "üéØ Trigger: ${{ github.event_name }}"
          
          if [ "$PENDING_COUNT" -gt 0 ]; then
            MANGA_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd "," -)
            TIMESTAMPS=$(jq -r '.pending[].timestamp' pending-manga-updates.json | paste -sd "," -)
            
            echo "should_rebuild=true" >> $GITHUB_OUTPUT
            echo "manga_list=$MANGA_LIST" >> $GITHUB_OUTPUT
            echo "‚úÖ Batch rebuild for: $MANGA_LIST"
            echo "üìÖ Update timestamps: $TIMESTAMPS"
            echo "::notice title=Batch Rebuild::Processing $PENDING_COUNT manga updates: $MANGA_LIST"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ] || [ "${{ github.event_name }}" == "schedule" ]; then
            echo "üîÑ Manual/Scheduled trigger with no pending updates"
            echo "üìö Extracting all manga repos from manga-config.js for full cover check..."
            
            # Extract all repo names from manga-config.js
            ALL_REPOS=$(grep -E "^\s*repo:\s*['\"]" manga-config.js | sed -E "s/.*repo:\s*['\"]([^'\"]+)['\"].*/\1/" | paste -sd "," -)
            REPO_COUNT=$(echo "$ALL_REPOS" | tr ',' '\n' | wc -l)
            
            echo "should_rebuild=true" >> $GITHUB_OUTPUT
            echo "manga_list=$ALL_REPOS" >> $GITHUB_OUTPUT
            echo "‚úÖ Full cover check mode: $REPO_COUNT manga repos"
            echo "üìã Repos: $ALL_REPOS"
            echo "::notice title=Full Cover Check::Manual trigger - checking all $REPO_COUNT manga repos for cover updates"
          else
            echo "should_rebuild=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No pending updates"
          fi
      
      - name: üñºÔ∏è Quick Cover Check
        id: cover_check
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          echo "üñºÔ∏è Checking if any manga needs cover update..."
          
          npm install --no-save node-fetch@2
          
          # Prepare manga list for cover check
          MANGA_LIST_CSV="${{ steps.check_rebuild.outputs.manga_list }}"
          echo "$MANGA_LIST_CSV" > manga-list.txt
          
          cat > check-covers.js << 'COVER_CHECK_EOF'
          const fs = require('fs');
          const fetch = require('node-fetch');
          
          // Read manga list from file (comma-separated)
          const mangaListCsv = fs.readFileSync('manga-list.txt', 'utf8').trim();
          const MANGA_LIST = mangaListCsv.split(',').map(repo => ({ repo: repo.trim() }));
          
          async function checkCover(repoName) {
            console.log(`\nüîç Checking: ${repoName}`);
            
            try {
              // Step 1: Fetch manga.json
              const url = `https://raw.githubusercontent.com/nurananto/${repoName}/main/manga.json`;
              console.log(`   üì• Fetching manga.json...`);
              const res = await fetch(url);
              if (!res.ok) {
                console.log(`   ‚ùå Failed to fetch manga.json (HTTP ${res.status})`);
                return null;
              }
              
              const data = await res.json();
              const currentCover = data.manga?.cover || '';
              console.log(`   üìÑ Current cover: ${currentCover || '(empty)'}`);
              
              // Step 2: Extract MangaDex ID
              const mdUrl = data.manga?.links?.mangadex;
              if (!mdUrl) {
                console.log(`   ‚ö†Ô∏è  No MangaDex link found`);
                return { repo: repoName, needsUpdate: false, reason: 'No MangaDex link' };
              }
              
              const mdId = mdUrl.match(/\/title\/([a-f0-9-]+)/)?.[1];
              if (!mdId) {
                console.log(`   ‚ö†Ô∏è  Invalid MangaDex URL format`);
                return { repo: repoName, needsUpdate: false, reason: 'Invalid MD URL' };
              }
              console.log(`   üîë MangaDex ID: ${mdId}`);
              
              // Step 3: Query MangaDex API for latest cover
              const apiUrl = `https://api.mangadex.org/cover?manga[]=${mdId}&limit=1&order[createdAt]=desc`;
              console.log(`   üåê Querying MangaDex API...`);
              const coverRes = await fetch(apiUrl);
              if (!coverRes.ok) {
                console.log(`   ‚ùå MangaDex API failed (HTTP ${coverRes.status})`);
                return null;
              }
              
              const coverData = await coverRes.json();
              if (!coverData.data?.[0]) {
                console.log(`   ‚ö†Ô∏è  No cover data from MangaDex`);
                return { repo: repoName, needsUpdate: false, reason: 'No cover on MD' };
              }
              
              // Step 4: Compare covers
              const latestFileName = coverData.data[0].attributes.fileName;
              const latestHash = latestFileName.split('.')[0];
              const latestFullUrl = `https://uploads.mangadex.org/covers/${mdId}/${latestFileName}`;
              
              console.log(`   üÜï Latest hash: ${latestHash}`);
              console.log(`   üÜï Latest URL: ${latestFullUrl}`);
              
              // Check if current cover contains latest hash OR is the exact URL
              const hasLatestHash = currentCover.includes(latestHash);
              const hasExactUrl = currentCover === latestFullUrl;
              const hasLatest = hasLatestHash || hasExactUrl;
              
              if (hasLatest) {
                console.log(`   ‚úÖ Cover is up-to-date`);
                return { repo: repoName, needsUpdate: false, reason: 'Already latest' };
              } else {
                console.log(`   üîÑ Cover needs update!`);
                return { 
                  repo: repoName, 
                  needsUpdate: true, 
                  hash: latestHash,
                  currentCover: currentCover,
                  latestUrl: latestFullUrl
                };
              }
              
            } catch (err) {
              console.log(`   ‚ùå Error: ${err.message}`);
              console.log(`   üìù Stack: ${err.stack}`);
              return null;
            }
          }
          
          (async () => {
            console.log(`üñºÔ∏è  Starting cover check for ${MANGA_LIST.length} manga...\n`);
            console.log('='.repeat(60));
            
            const results = [];
            for (const item of MANGA_LIST) {
              const result = await checkCover(item.repo);
              if (result) results.push(result);
              await new Promise(r => setTimeout(r, 1000));
            }
            
            console.log('\n' + '='.repeat(60));
            const needsUpdate = results.filter(r => r.needsUpdate);
            console.log(`\nüìä Cover Check Summary:`);
            console.log(`   Total checked: ${results.length}`);
            console.log(`   Needs update: ${needsUpdate.length}`);
            console.log(`   Up-to-date: ${results.length - needsUpdate.length}`);
            
            if (needsUpdate.length > 0) {
              console.log(`\nüñºÔ∏è  Manga requiring cover update:`);
              needsUpdate.forEach(r => {
                console.log(`   - ${r.repo}`);
                console.log(`     Current: ${r.currentCover || '(empty)'}`);
                console.log(`     Latest: ${r.latestUrl}`);
              });
            } else {
              console.log(`\n‚úÖ All covers are up-to-date!`);
            }
            
            fs.writeFileSync('cover-check-result.json', JSON.stringify({ 
              needsUpdate: needsUpdate.length > 0,
              details: results
            }));
          })();
          COVER_CHECK_EOF
          
          node check-covers.js || echo "Cover check failed, continuing..."
          
          if [ -f cover-check-result.json ]; then
            NEEDS_UPDATE=$(cat cover-check-result.json | jq -r '.needsUpdate')
            echo "needs_cover_update=$NEEDS_UPDATE" >> $GITHUB_OUTPUT
          else
            echo "needs_cover_update=false" >> $GITHUB_OUTPUT
          fi
      
      - name: üîÑ Update Covers (If Needed)
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_ACCESS_KEY_ID: ${{ secrets.CF_ACCESS_KEY_ID }}
          CF_SECRET_ACCESS_KEY: ${{ secrets.CF_SECRET_ACCESS_KEY }}
          R2_PUBLIC_DOMAIN: ${{ secrets.R2_PUBLIC_DOMAIN }}
        run: |
          echo "üñºÔ∏è Updating covers..."
          npm install sharp @aws-sdk/client-s3
          node download-covers-r2.js || echo "Cover update failed, continuing..."
          
          if [[ -n $(git status -s manga-config.js) ]]; then
            git add manga-config.js updated-repo-list.txt
            git commit -m "üñºÔ∏è Auto-update covers [skip ci]" || true
            git push || true
            echo "‚úÖ Covers updated"
            
            # Wait for GitHub to process the commit before triggering sync
            echo "‚è≥ Waiting 5 seconds for GitHub to process commit..."
            sleep 5
          fi
      
      - name: üì§ Trigger Cover Sync to Updated Manga Repos ONLY
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          set +e  # Don't exit on error
          
          # ‚úÖ FIX: Check if PAT_TOKEN is set and not empty
          if [ -z "${PAT_TOKEN}" ] || [ "${PAT_TOKEN}" = "" ]; then
            echo "‚ö†Ô∏è PAT_TOKEN secret is not set in GitHub Secrets"
            echo "::warning::PAT_TOKEN secret is required to trigger cover sync workflows"
            echo "::warning::Please add PAT_TOKEN to GitHub Secrets (Settings > Secrets and variables > Actions)"
            echo "::warning::PAT_TOKEN needs 'actions:write' permission"
            exit 0  # Don't fail the workflow, just skip
          fi
          
          echo "üì§ Triggering cover sync to repos with updated covers ONLY..."
          
          # Use updated-repo-list.txt instead of repo-list.txt
          REPO_FILE="updated-repo-list.txt"
          
          if [ ! -f "$REPO_FILE" ]; then
            echo "‚ÑπÔ∏è No updated-repo-list.txt found - no repos to trigger"
            exit 0
          fi
          
          repo_count=$(wc -l < "$REPO_FILE")
          
          if [ "$repo_count" -eq 0 ]; then
            echo "‚ÑπÔ∏è No repos in updated list - skipping triggers"
            exit 0
          fi
          
          echo "üìä Found $repo_count repos with cover updates"
          
          success=0
          failed=0
          skipped=0
          
          while IFS= read -r repo; do
            if [ -z "$repo" ]; then
              continue
            fi
            
            echo "  [TRIGGER] $repo..."
            
            http_code=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${PAT_TOKEN}" \
              https://api.github.com/repos/nurananto/$repo/dispatches \
              -d '{"event_type":"sync-covers"}' 2>&1 || echo "000")
            
            if [ "$http_code" = "204" ]; then
              echo "    ‚úÖ Success"
              success=$((success + 1))
            elif [ "$http_code" = "404" ]; then
              echo "    ‚ö†Ô∏è Workflow not found (HTTP 404)"
              skipped=$((skipped + 1))
            elif [ "$http_code" = "403" ]; then
              echo "    ‚ö†Ô∏è Permission denied (HTTP 403) - PAT_TOKEN may not have 'actions:write' permission"
              failed=$((failed + 1))
            else
              echo "    ‚ùå Failed (HTTP $http_code)"
              failed=$((failed + 1))
            fi
            
            sleep 1
          done < "$REPO_FILE"
          
          echo ""
          echo "=========================================="
          echo "üì§ Cover Sync Trigger Summary:"
          echo "   ‚úÖ Success: $success repos"
          echo "   ‚ö†Ô∏è Skipped: $skipped repos (workflow missing)"
          echo "   ‚ùå Failed: $failed repos"
          echo "   üìä Total Updated: $repo_count repos"
          echo "   ‚ÑπÔ∏è  Repos will update with [skip ci]"
          echo "=========================================="
          
          # Exit with success if at least one trigger succeeded
          if [ $success -gt 0 ]; then
            echo ""
            echo "‚úÖ At least $success repos triggered successfully"
            exit 0
          elif [ $skipped -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è No triggers succeeded, but $skipped repos need sync-cover.yml"
            exit 0
          else
            echo ""
            echo "‚ùå All trigger attempts failed"
            exit 1
          fi
      
      - name: üßπ Cleanup Updated Repo List
        if: |
          steps.check_rebuild.outputs.should_rebuild == 'true' &&
          steps.cover_check.outputs.needs_cover_update == 'true'
        run: |
          echo "üßπ Cleaning up updated-repo-list.txt..."
          
          if [ -f "updated-repo-list.txt" ]; then
            git config --local user.name "github-actions[bot]"
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            
            rm updated-repo-list.txt
            git add updated-repo-list.txt
            git commit -m "üßπ Cleanup updated repo list [skip ci]" || echo "No changes to commit"
            git push || echo "Push failed"
            
            echo "‚úÖ updated-repo-list.txt removed"
          else
            echo "‚ÑπÔ∏è File not found, nothing to clean"
          fi
      
      - name: üíæ Commit Changes (Without Version Bump)
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          MANGA_LIST="${{ steps.check_rebuild.outputs.manga_list }}"
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Hanya commit jika ada perubahan selain version.txt dan sw.js
          # Version bump akan dihandle oleh auto-version.yml setelah deploy
          if [[ -n $(git status -s) ]]; then
            git add -A
            git reset HEAD version.txt sw.js index.html info-manga.html reader.html || true
            if [[ -n $(git status -s) ]]; then
              git commit -m "üîÑ Batch rebuild: $MANGA_LIST [skip ci]" || echo "No changes"
              git push || echo "Push failed"
              echo "‚úÖ Changes committed (version bump will be handled by auto-version)"
            else
              echo "‚ÑπÔ∏è No changes to commit (only version files changed)"
            fi
          else
            echo "‚ÑπÔ∏è No changes to commit"
          fi
      
      - name: üßπ Clear Pending
        if: steps.check_rebuild.outputs.should_rebuild == 'true'
        run: |
          PROCESSED_COUNT=$(jq '.pending | length' pending-manga-updates.json)
          PROCESSED_LIST=$(jq -r '.pending[].repo' pending-manga-updates.json | paste -sd ", " -)
          
          echo "üßπ Clearing $PROCESSED_COUNT processed updates: $PROCESSED_LIST"
          
          jq --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '.pending = [] | .lastRebuild = $ts' \
            pending-manga-updates.json > temp.json && mv temp.json pending-manga-updates.json
          
          echo "üìã After clear:"
          cat pending-manga-updates.json | jq '.'
          
          git add pending-manga-updates.json
          git commit -m "üßπ Clear $PROCESSED_COUNT pending updates: $PROCESSED_LIST [skip ci]"
          git push
          
          echo "‚úÖ Pending cleared and committed"
          echo "::notice title=Pending Cleared::Processed and cleared $PENDING_COUNT manga updates"

  # ‚úÖ Separate job to deploy pages
  deploy-pages:
    needs: batch-updates
    if: needs.batch-updates.outputs.should_rebuild == 'true'
    permissions:
      contents: read
      pages: write
      id-token: write
      actions: write  # ‚úÖ Required for trigger-auto-version job in deploy-pages.yml
    uses: ./.github/workflows/deploy-pages.yml
  
  # ‚úÖ Cache purge sudah dihandle oleh auto-version.yml setelah deploy
  # Job ini dihapus untuk menghindari duplikasi
